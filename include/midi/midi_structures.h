#include <stdint.h>
#include <stdbool.h>
#include <pthread.h>
#include "asoundlib.h"
#include <glib.h>

/**
 * A constant that defines a maximum port name length
 */
#define MAX_PORT_NAME_LEN 128

/**
 * A custom structure that contains names
 * and numbers related to a certain MIDI
 * port in Alsa.
 */
typedef struct MIDI_port {
    /** MIDI port number; related to iteration in port_info function and its port_number argument */
    unsigned int id;
    /** A name of ALSA's :c:type:`snd_seq_client_info_t` container */
    char client_info_name[MAX_PORT_NAME_LEN];
    /** A name of ALSA's :c:type:`snd_seq_port_info_t` container */
    char port_info_name[MAX_PORT_NAME_LEN];
    /** A client id of ALSA's :c:type:`snd_seq_port_info_t` container */
    int port_info_client_id;
    /** A port id of ALSA's :c:type:`snd_seq_port_info_t` container */
    int port_info_id;
} MIDI_port;

typedef struct Port_config {
    const char * seq_name;
    const char * virtual_seq_name;
} Port_config;

/**
 * A struct to store a single MIDI message in a form of
 * a buffer, its length and a timestamp.
 */
typedef struct MIDI_message {
    /** Same as bytes, but just an allocated array */
    unsigned char * buf;
    /** Length of buf */
    long count;
    /** Time in seconds elapsed since the previous message */
    double timestamp;
} MIDI_message;

/**
 * A structure to hold variables
 * related to the ALSA API implementation.
 */
typedef struct Alsa_MIDI_data {
    /** A pointer to Alsa MIDI `sequencer handle <https://www.alsa-project.org/alsa-doc/alsa-lib/group___sequencer.html>`_ */
    snd_seq_t * seq;
    /** Seems to be a MIDI port number that is only set to "-1" now. */
    unsigned int port_num;
    /** A receiver or sender port number, generated by :c:func:`snd_seq_create_simple_port` */
    int vport;
    /** A pointer to ALSA port subscription container instance */
    snd_seq_port_subscribe_t * subscription;
    /** A pointer to Alsa MIDI `sequencer event parser <https://www.alsa-project.org/alsa-doc/alsa-lib/group___m_i_d_i___event.html>`_ */
    snd_midi_event_t * coder;
    /** A **bufsize** value for MIDI event parser (:c:func:`snd_midi_event_new`). */
    unsigned int buffer_size;
    /** A MIDI message buffer. */
    unsigned char * buffer;
    /** An input thread instance */
    pthread_t thread;
    /** The ID of the calling thread generated by a :c:func:`pthread_self` function */
    pthread_t dummy_thread_id;
    /** :c:type:`snd_seq_real_time_t` instance decoded from Alsa MIDI event, contains nanosecond and second values */
    snd_seq_real_time_t last_time;
    /** An input queue is needed to get timestamped events */
    int queue_id;
    /** File descriptors set by a pipe call in "start_input_seq" function. */
    int trigger_fds[2];
    /** Tells if a MIDI port is connected, set by :c:func:`open_port` */
    bool port_connected;
} Alsa_MIDI_data;

/**
 * A struct to be passed to a :c:func:`pthread_create` call.
 */
typedef struct MIDI_in_data {
    /** A GLib asynchronous que to store MIDI messages */
    GAsyncQueue * midi_async_queue;
    /** A GLib asynchronous que to store errors */
    GAsyncQueue * error_async_queue;
    /** A :c:type:`MIDI_message` instance */
    MIDI_message message;
    /** ? */
    unsigned char ignore_flags;
    /** Marks if data input thread was started */
    bool do_input;
    /** ? */
    bool first_message;
    /** Marks if a callback is used; set by :c:func:`set_MIDI_in_callback` */
    bool using_callback;
    /** Current MIDI callback pointer to be called on a message */
    MIDI_callback user_callback;
    /** Additional data passed to a callback, seems to always be a void pointer */
    void * user_data;
    /** Determines if previous message should be extended
        or a new array should be created */
    bool continue_sysex;
    /** Alsa_MIDI_data instance */
    Alsa_MIDI_data * amidi_data;
} MIDI_in_data;
